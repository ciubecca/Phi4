eigs.py 10 1 13
EL, ELp, ELpp 39.0 26.0 39.0
computing V 2
computing V 4
k= 1
Full basis size:  506
g= 1.0
Raw vacuum: -0.244909602224
Total number of tails: 506
Generating high energy basis...
Filename: /Users/lorenzovitale/Phi4/statefuncs.py

Line #    Mem usage    Increment   Line Contents
================================================
    85  203.480 MiB    0.000 MiB       @profile
    86                                 def __init__(self, k, stateset, helper):
    87                                     """ Standard constructor
    88                                     k: parity quantum number
    89                                     stateset: set or list of states in representation 1
    90                                     helper: Helper object
    91                                     orderEnergy: if True order the list of vectors in energy
    92                                     calcPos: if True construct the dictionary of the positions of the vectors
    93                                     """
    94  203.480 MiB    0.000 MiB           self.k = k
    95  203.480 MiB    0.000 MiB           self.helper = helper
    96  203.480 MiB    0.000 MiB           energy = helper.energy
    97  203.480 MiB    0.000 MiB           self.nmax = self.helper.nmax
    98                             
    99                                     # Avoid creating another list in memory if it already a sorted list
   100  203.480 MiB    0.000 MiB           if type(stateset)==list and isSorted(stateset, energy):
   101                                         self.stateList = stateset
   102                                     else:
   103   65.211 MiB -138.270 MiB               self.stateList = sorted(stateset, key=energy)
   104   65.211 MiB    0.000 MiB           self.size = len(self.stateList)
   105                             
   106   65.211 MiB    0.000 MiB           self.energyList = [energy(state) for state in self.stateList]
   107   65.211 MiB    0.000 MiB           self.occnList = [occn(state) for state in self.stateList]
   108   65.211 MiB    0.000 MiB           self.parityList = [int(state==reverse(state)) for state in self.stateList]
   109                             
   110   65.211 MiB    0.000 MiB           try:
   111   65.211 MiB    0.000 MiB               self.Emax = max(self.energyList)
   112   65.211 MiB    0.000 MiB               self.Emin = min(self.energyList)
   113                                     # When the basis is empty
   114                                     except IndexError:
   115                                         self.Emax = None
   116                                         self.Emin = None


Filename: /Users/lorenzovitale/Phi4/matrix.py

Line #    Mem usage    Increment   Line Contents
================================================
    54   61.238 MiB    0.000 MiB       @profile
    55                                 def __init__(self, basis, lookupbasis, Erange=None):
    56                                     """
    57                                     basis: basis for the row elements
    58                                     lookupbasis: basis for the columns elements
    59                                     Emin: minimal energy of the states to be generated
    60                                     Emax: maximal energy of the states to be generated
    61                                     """
    62   61.238 MiB    0.000 MiB           self.basis = basis
    63   61.238 MiB    0.000 MiB           self.lookupbasis = lookupbasis
    64                             
    65   61.238 MiB    0.000 MiB           if basis.helper.nmax > lookupbasis.helper.nmax:
    66                                         self.helper = basis.helper
    67                                     else:
    68   61.238 MiB    0.000 MiB               self.helper = lookupbasis.helper
    69                             
    70   61.238 MiB    0.000 MiB           if Erange==None:
    71   61.242 MiB    0.004 MiB               Erange = (lookupbasis.Emin, lookupbasis.Emax)
    72   61.242 MiB    0.000 MiB           self.Erange = Erange
    73                             
    74   61.297 MiB    0.055 MiB           self.statePos = buildStatePos(lookupbasis, self.helper, Erange)


Filename: /Users/lorenzovitale/Phi4/matrix.py

Line #    Mem usage    Increment   Line Contents
================================================
    76   62.699 MiB    0.000 MiB       @profile
    77                                 def buildMatrix(self, Vlist, ignKeyErr=False, idxList=None, sumTranspose=False):
    78                                     """
    79                                     Vlist: list of oscillators
    80                                     ignKeyErr: whether LookupError when generating a state should be ignored (to be used
    81                                     when the lookupbasis does not contain all the states between Emin and Emax)
    82                                     idxList: list of the row indices to be computed
    83                                     sumTranspose: whether the tranpose of the matrix should be added and the diagonal
    84                                     subtracted
    85                                     """
    86                             
    87   62.699 MiB    0.000 MiB           basis = self.basis
    88   62.699 MiB    0.000 MiB           lookupbasis = self.lookupbasis
    89   62.699 MiB    0.000 MiB           Erange = self.Erange
    90   62.699 MiB    0.000 MiB           statePos = self.statePos
    91   62.699 MiB    0.000 MiB           helper = self.helper
    92                             
    93   62.699 MiB    0.000 MiB           if idxList==None:
    94   62.699 MiB    0.000 MiB               idxList = range(basis.size)
    95                             
    96                                     # Will construct the sparse matrix in the COO format and then convert it to CSC
    97   62.699 MiB    0.000 MiB           data = []
    98   62.699 MiB    0.000 MiB           row = []
    99   62.699 MiB    0.000 MiB           col = []
   100                             
   101   63.938 MiB    1.238 MiB           for V in Vlist:
   102   63.938 MiB    0.000 MiB               for i in idxList:
   103                                             colpart, datapart = \
   104   63.938 MiB    0.000 MiB                       V.computeMatrixElements(basis,i,lookupbasis, Erange=Erange,
   105   63.938 MiB    0.000 MiB                               statePos=statePos, helper=helper, ignKeyErr=ignKeyErr)
   106   63.938 MiB    0.000 MiB                   data += datapart
   107   63.938 MiB    0.000 MiB                   col += colpart
   108   63.938 MiB    0.000 MiB                   row += [i]*len(colpart)
   109                             
   110                                     # XXX Does this sum duplicate entries?
   111   64.070 MiB    0.133 MiB           V = scipy.sparse.coo_matrix((data,(row,col)), shape=(basis.size,lookupbasis.size))
   112                             
   113   64.070 MiB    0.000 MiB           if sumTranspose:
   114                                         # Add the matrix to its transpose and subtract the diagonal
   115   64.070 MiB    0.000 MiB               diag_V = scipy.sparse.spdiags(V.diagonal(),0,basis.size,basis.size).tocsc()
   116   65.016 MiB    0.945 MiB               return (V+V.transpose()-diag_V)
   117                                     else:
   118                                         return V


eigs.py 10 1 13
EL, ELp, ELpp 39.0 26.0 39.0
computing V 2
computing V 4
k= 1
Full basis size:  506
g= 1.0
Raw vacuum: -0.244909602224
Total number of tails: 506
Generating high energy basis...
Filename: /Users/lorenzovitale/Phi4/statefuncs.py

Line #    Mem usage    Increment   Line Contents
================================================
    85   64.957 MiB    0.000 MiB       @profile
    86                                 def __init__(self, k, stateset, helper):
    87                                     """ Standard constructor
    88                                     k: parity quantum number
    89                                     stateset: set or list of states in representation 1
    90                                     helper: Helper object
    91                                     orderEnergy: if True order the list of vectors in energy
    92                                     calcPos: if True construct the dictionary of the positions of the vectors
    93                                     """
    94   64.957 MiB    0.000 MiB           self.k = k
    95   64.957 MiB    0.000 MiB           self.helper = helper
    96   64.957 MiB    0.000 MiB           energy = helper.energy
    97   64.957 MiB    0.000 MiB           self.nmax = self.helper.nmax
    98                             
    99                                     # Avoid creating another list in memory if it already a sorted list
   100   64.957 MiB    0.000 MiB           if type(stateset)==list and isSorted(stateset, energy):
   101                                         self.stateList = stateset
   102                                     else:
   103   64.957 MiB    0.000 MiB               self.stateList = sorted(stateset, key=energy)
   104   64.957 MiB    0.000 MiB           self.size = len(self.stateList)
   105                             
   106   64.957 MiB    0.000 MiB           self.energyList = [energy(state) for state in self.stateList]
   107   64.957 MiB    0.000 MiB           self.occnList = [occn(state) for state in self.stateList]
   108   64.957 MiB    0.000 MiB           self.parityList = [int(state==reverse(state)) for state in self.stateList]
   109                             
   110   64.957 MiB    0.000 MiB           try:
   111   64.957 MiB    0.000 MiB               self.Emax = max(self.energyList)
   112   64.957 MiB    0.000 MiB               self.Emin = min(self.energyList)
   113                                     # When the basis is empty
   114                                     except IndexError:
   115                                         self.Emax = None
   116                                         self.Emin = None


Filename: /Users/lorenzovitale/Phi4/matrix.py

Line #    Mem usage    Increment   Line Contents
================================================
    54   61.285 MiB    0.000 MiB       @profile
    55                                 def __init__(self, basis, lookupbasis, Erange=None):
    56                                     """
    57                                     basis: basis for the row elements
    58                                     lookupbasis: basis for the columns elements
    59                                     Emin: minimal energy of the states to be generated
    60                                     Emax: maximal energy of the states to be generated
    61                                     """
    62   61.285 MiB    0.000 MiB           self.basis = basis
    63   61.285 MiB    0.000 MiB           self.lookupbasis = lookupbasis
    64                             
    65   61.285 MiB    0.000 MiB           if basis.helper.nmax > lookupbasis.helper.nmax:
    66                                         self.helper = basis.helper
    67                                     else:
    68   61.285 MiB    0.000 MiB               self.helper = lookupbasis.helper
    69                             
    70   61.285 MiB    0.000 MiB           if Erange==None:
    71   61.285 MiB    0.000 MiB               Erange = (lookupbasis.Emin, lookupbasis.Emax)
    72   61.285 MiB    0.000 MiB           self.Erange = Erange
    73                             
    74   61.340 MiB    0.055 MiB           self.statePos = buildStatePos(lookupbasis, self.helper, Erange)


Filename: /Users/lorenzovitale/Phi4/matrix.py

Line #    Mem usage    Increment   Line Contents
================================================
    76   62.801 MiB    0.000 MiB       @profile
    77                                 def buildMatrix(self, Vlist, ignKeyErr=False, idxList=None, sumTranspose=False):
    78                                     """
    79                                     Vlist: list of oscillators
    80                                     ignKeyErr: whether LookupError when generating a state should be ignored (to be used
    81                                     when the lookupbasis does not contain all the states between Emin and Emax)
    82                                     idxList: list of the row indices to be computed
    83                                     sumTranspose: whether the tranpose of the matrix should be added and the diagonal
    84                                     subtracted
    85                                     """
    86                             
    87   62.801 MiB    0.000 MiB           basis = self.basis
    88   62.801 MiB    0.000 MiB           lookupbasis = self.lookupbasis
    89   62.801 MiB    0.000 MiB           Erange = self.Erange
    90   62.801 MiB    0.000 MiB           statePos = self.statePos
    91   62.801 MiB    0.000 MiB           helper = self.helper
    92                             
    93   62.801 MiB    0.000 MiB           if idxList==None:
    94   62.801 MiB    0.000 MiB               idxList = range(basis.size)
    95                             
    96                                     # Will construct the sparse matrix in the COO format and then convert it to CSC
    97   62.801 MiB    0.000 MiB           data = []
    98   62.801 MiB    0.000 MiB           row = []
    99   62.801 MiB    0.000 MiB           col = []
   100                             
   101   63.816 MiB    1.016 MiB           for V in Vlist:
   102   63.816 MiB    0.000 MiB               for i in idxList:
   103                                             colpart, datapart = \
   104   63.816 MiB    0.000 MiB                       V.computeMatrixElements(basis,i,lookupbasis, Erange=Erange,
   105   63.816 MiB    0.000 MiB                               statePos=statePos, helper=helper, ignKeyErr=ignKeyErr)
   106   63.816 MiB    0.000 MiB                   data += datapart
   107   63.816 MiB    0.000 MiB                   col += colpart
   108   63.816 MiB    0.000 MiB                   row += [i]*len(colpart)
   109                             
   110                                     # XXX Does this sum duplicate entries?
   111   63.949 MiB    0.133 MiB           V = scipy.sparse.coo_matrix((data,(row,col)), shape=(basis.size,lookupbasis.size))
   112                             
   113   63.949 MiB    0.000 MiB           if sumTranspose:
   114                                         # Add the matrix to its transpose and subtract the diagonal
   115   63.949 MiB    0.000 MiB               diag_V = scipy.sparse.spdiags(V.diagonal(),0,basis.size,basis.size).tocsc()
   116   64.762 MiB    0.812 MiB               return (V+V.transpose()-diag_V)
   117                                     else:
   118                                         return V


Filename: eigs.py

Line #    Mem usage    Increment   Line Contents
================================================
    45   60.984 MiB    0.000 MiB   @profile
    46                             def main():
    47                             
    48   60.984 MiB    0.000 MiB       if saveondb:
    49                                     db = database.Database()
    50                             
    51   60.992 MiB    0.008 MiB       a = phi4.Phi4(m, L)
    52   61.258 MiB    0.266 MiB       a.buildBasis(Emax=ET)
    53                             
    54                             
    55   61.258 MiB    0.000 MiB       for k in klist:
    56                             
    57                                     # Compute the potential matrices in the low-energy space below ET
    58   64.762 MiB    3.504 MiB           a.computePotential(k)
    59                             
    60   64.762 MiB    0.000 MiB           print("k=", k)
    61   64.762 MiB    0.000 MiB           print("Full basis size: ", a.basis[k].size)
    62                             
    63   64.762 MiB    0.000 MiB           a.setCouplings(g4=g)
    64   64.762 MiB    0.000 MiB           print("g=", g)
    65                             
    66                             
    67                             # Compute the raw eigenvalues for cutoff ET
    68   64.934 MiB    0.172 MiB           a.computeEigval(k, ET, "raw", neigs=neigs)
    69   64.957 MiB    0.023 MiB           print("Raw vacuum:", a.eigenvalues["raw"][k][0])
    70   64.957 MiB    0.000 MiB           eps = a.eigenvalues["raw"][k][0]
    71                             
    72                             
    73                             
    74                                     # Select a set of tails and construct a Basis object
    75   64.957 MiB    0.000 MiB           vectorlist = [state for i,state in sorted(enumerate(a.basis[k]), key=lambda x:
    76   64.957 MiB    0.000 MiB                   -abs(a.eigenvectors["raw"][k][0][x[0]]))]
    77   64.957 MiB    0.000 MiB           if maxntails != None:
    78                                         vectorlist = vectorlist[:maxntails]
    79   64.957 MiB    0.000 MiB           basisl = statefuncs.Basis(k, vectorlist, a.basis[k].helper)
    80   64.957 MiB    0.000 MiB           print("Total number of tails:", basisl.size)
    81                             
    82                             
    83   64.957 MiB    0.000 MiB           print("Generating high energy basis...")
    84                                     # Generate the high-energy "selected" basis by passing a set of tails
    85                                     # and a maximum cutoff EL
    86  117.324 MiB   52.367 MiB           a.genHEBasis(k, basisl, EL=EL, ELp=ELp, ELpp=ELpp)
    87                                     print("Size of HE basis:", a.basisH[k].size)
    88                             
    89                                     a.computeLEVs(k, loc3=loc3)
    90                             
    91                             
    92                                     print("Computing high energy matrices...")
    93                             # Compute the matrices VLH, VHL, VHH, for the highest local cutoff ELmax.
    94                             # Later we will be varying EL, therefore taking submatrices of these.
    95                             # Computing VHH is expensive
    96                                     a.computeHEVs(k)
    97                             
    98                             
    99                                     a.computeEigval(k, ET, "renloc", eps=eps, neigs=neigs)
   100                                     print("Local ren vacuum:", a.eigenvalues["renloc"][k][0])
   101                                     eps = a.eigenvalues["renloc"][k][0]
   102                             
   103                                     if loc3:
   104                                         a.calcVV3([ELp], eps)
   105                             
   106                                     a.computeEigval(k, ET, "rentails", EL=EL, ELp=ELp, ELpp=ELpp, eps=eps,
   107                                             neigs=neigs, loc3=loc3,loc3mix=loc3mix, nonloc3mix=nonloc3mix)
   108                                     print("Non-Local ren vacuum:", a.eigenvalues["rentails"][k][0])
   109                             
   110                             
   111                                     print("Number of tails:", a.ntails)
   112                             
   113                                     if saveondb:
   114                                         datadict = dict(k=k, ET=ET, L=L, ren="raw", g=g, neigs=neigs,
   115                                                 basisSize=a.compSize)
   116                                         db.insert(datadict=datadict, spec=a.eigenvalues["raw"][k])
   117                             
   118                             
   119                                         datadict = dict(k=k, ET=ET, L=L, ren="renloc", g=g, eps=eps, neigs=neigs,
   120                                                 basisSize=a.compSize)
   121                                         db.insert(datadict=datadict, spec=a.eigenvalues["renloc"][k])
   122                             
   123                             
   124                                         datadict = dict(k=k, ET=ET, L=L, ren="rentails", g=g, EL=EL, ELp=ELp, ELpp=ELpp,
   125                                                 ntails=a.ntails, eps=eps, neigs=neigs, basisSize=a.compSize,
   126                                                 tailsComputedAtET=ET, maxntails=maxntails)
   127                                         db.insert(datadict=datadict, spec=a.eigenvalues["rentails"][k])


eigs.py 10 1 13
EL, ELp, ELpp 39.0 26.0 39.0
computing V 2
computing V 4
k= 1
Full basis size:  506
g= 1.0
Raw vacuum: -0.244909602224
Total number of tails: 506
Generating high energy basis...
Size of HE basis: 749930
Computing high energy matrices...
Computing VHl...
Computing VHL...
self.VLH[k] size 24.521472
Local ren vacuum: -0.401289538025
Computing DH3
Total number of chunks:  5
Doing chunk 0 for Vhh
Doing chunk 1 for Vhh
Doing chunk 2 for Vhh
Doing chunk 3 for Vhh
Doing chunk 4 for Vhh
doing chunk 0 for VhH
doing chunk 1 for VhH
doing chunk 2 for VhH
doing chunk 3 for VhH
doing chunk 4 for VhH
Non-Local ren vacuum: -0.389363804467
Number of tails: 506
Filename: /Users/lorenzovitale/Phi4/statefuncs.py

Line #    Mem usage    Increment   Line Contents
================================================
    85  203.512 MiB    0.000 MiB       @profile
    86                                 def __init__(self, k, stateset, helper):
    87                                     """ Standard constructor
    88                                     k: parity quantum number
    89                                     stateset: set or list of states in representation 1
    90                                     helper: Helper object
    91                                     orderEnergy: if True order the list of vectors in energy
    92                                     calcPos: if True construct the dictionary of the positions of the vectors
    93                                     """
    94  203.512 MiB    0.000 MiB           self.k = k
    95  203.512 MiB    0.000 MiB           self.helper = helper
    96  203.512 MiB    0.000 MiB           energy = helper.energy
    97  203.512 MiB    0.000 MiB           self.nmax = self.helper.nmax
    98                             
    99                                     # Avoid creating another list in memory if it already a sorted list
   100  203.512 MiB    0.000 MiB           if type(stateset)==list and isSorted(stateset, energy):
   101                                         self.stateList = stateset
   102                                     else:
   103  760.223 MiB  556.711 MiB               self.stateList = sorted(stateset, key=energy)
   104  760.223 MiB    0.000 MiB           self.size = len(self.stateList)
   105                             
   106  769.254 MiB    9.031 MiB           self.energyList = [energy(state) for state in self.stateList]
   107  774.062 MiB    4.809 MiB           self.occnList = [occn(state) for state in self.stateList]
   108  774.789 MiB    0.727 MiB           self.parityList = [int(state==reverse(state)) for state in self.stateList]
   109                             
   110  770.371 MiB   -4.418 MiB           try:
   111  773.242 MiB    2.871 MiB               self.Emax = max(self.energyList)
   112  773.242 MiB    0.000 MiB               self.Emin = min(self.energyList)
   113                                     # When the basis is empty
   114                                     except IndexError:
   115                                         self.Emax = None
   116                                         self.Emin = None


Filename: /Users/lorenzovitale/Phi4/matrix.py

Line #    Mem usage    Increment   Line Contents
================================================
    54  894.020 MiB    0.000 MiB       @profile
    55                                 def __init__(self, basis, lookupbasis, Erange=None):
    56                                     """
    57                                     basis: basis for the row elements
    58                                     lookupbasis: basis for the columns elements
    59                                     Emin: minimal energy of the states to be generated
    60                                     Emax: maximal energy of the states to be generated
    61                                     """
    62  894.020 MiB    0.000 MiB           self.basis = basis
    63  894.020 MiB    0.000 MiB           self.lookupbasis = lookupbasis
    64                             
    65  894.020 MiB    0.000 MiB           if basis.helper.nmax > lookupbasis.helper.nmax:
    66                                         self.helper = basis.helper
    67                                     else:
    68  894.020 MiB    0.000 MiB               self.helper = lookupbasis.helper
    69                             
    70  894.020 MiB    0.000 MiB           if Erange==None:
    71  725.996 MiB -168.023 MiB               Erange = (lookupbasis.Emin, lookupbasis.Emax)
    72  894.020 MiB  168.023 MiB           self.Erange = Erange
    73                             
    74 1060.250 MiB  166.230 MiB           self.statePos = buildStatePos(lookupbasis, self.helper, Erange)


Filename: /Users/lorenzovitale/Phi4/matrix.py

Line #    Mem usage    Increment   Line Contents
================================================
    76 1067.008 MiB    0.000 MiB       @profile
    77                                 def buildMatrix(self, Vlist, ignKeyErr=False, idxList=None, sumTranspose=False):
    78                                     """
    79                                     Vlist: list of oscillators
    80                                     ignKeyErr: whether LookupError when generating a state should be ignored (to be used
    81                                     when the lookupbasis does not contain all the states between Emin and Emax)
    82                                     idxList: list of the row indices to be computed
    83                                     sumTranspose: whether the tranpose of the matrix should be added and the diagonal
    84                                     subtracted
    85                                     """
    86                             
    87 1067.008 MiB    0.000 MiB           basis = self.basis
    88 1067.008 MiB    0.000 MiB           lookupbasis = self.lookupbasis
    89 1067.008 MiB    0.000 MiB           Erange = self.Erange
    90 1067.008 MiB    0.000 MiB           statePos = self.statePos
    91 1067.008 MiB    0.000 MiB           helper = self.helper
    92                             
    93 1067.008 MiB    0.000 MiB           if idxList==None:
    94 1067.008 MiB    0.000 MiB               idxList = range(basis.size)
    95                             
    96                                     # Will construct the sparse matrix in the COO format and then convert it to CSC
    97 1067.008 MiB    0.000 MiB           data = []
    98 1067.008 MiB    0.000 MiB           row = []
    99 1067.008 MiB    0.000 MiB           col = []
   100                             
   101 1076.266 MiB    9.258 MiB           for V in Vlist:
   102 1078.820 MiB    2.555 MiB               for i in idxList:
   103                                             colpart, datapart = \
   104 1078.820 MiB    0.000 MiB                       V.computeMatrixElements(basis,i,lookupbasis, Erange=Erange,
   105 1078.828 MiB    0.008 MiB                               statePos=statePos, helper=helper, ignKeyErr=ignKeyErr)
   106 1078.828 MiB    0.000 MiB                   data += datapart
   107 1078.820 MiB   -0.008 MiB                   col += colpart
   108 1078.820 MiB    0.000 MiB                   row += [i]*len(colpart)
   109                             
   110                                     # XXX Does this sum duplicate entries?
   111 1123.082 MiB   44.262 MiB           V = scipy.sparse.coo_matrix((data,(row,col)), shape=(basis.size,lookupbasis.size))
   112                             
   113 1123.082 MiB    0.000 MiB           if sumTranspose:
   114                                         # Add the matrix to its transpose and subtract the diagonal
   115   63.863 MiB -1059.219 MiB               diag_V = scipy.sparse.spdiags(V.diagonal(),0,basis.size,basis.size).tocsc()
   116   64.945 MiB    1.082 MiB               return (V+V.transpose()-diag_V)
   117                                     else:
   118 1123.082 MiB 1058.137 MiB               return V


Filename: /Users/lorenzovitale/Phi4/phi4.py

Line #    Mem usage    Increment   Line Contents
================================================
    92   65.297 MiB    0.000 MiB       @profile
    93                                 def genHEBasis(self, k, basisl, EL, ELp, ELpp):
    94                                     """ Generate a high-energy basis from a set of tails
    95                                     k: parity quantum number
    96                                     basisl: Basis instance containing the set of tails
    97                                     EL: maximal energy of the generated basis for DH2
    98                                     ELpp: maximal energy of the generated basis for DH3
    99                                     """
   100                             
   101   65.297 MiB    0.000 MiB           self.basisl[k] = basisl
   102                             
   103   65.297 MiB    0.000 MiB           self.EL = EL
   104   65.297 MiB    0.000 MiB           self.ELp = ELp
   105   65.297 MiB    0.000 MiB           self.ELpp = ELpp
   106   65.297 MiB    0.000 MiB           Emax = max(EL, ELp, ELpp)
   107                             
   108                                     # Generate all the operators between the selected states and the states
   109                                     # in the range [0, Emax]
   110   71.887 MiB    6.590 MiB           Vlist = V4OpsSelectedFull(basisl, Emax)
   111   71.887 MiB    0.000 MiB           vectorset = set()
   112                             
   113  203.512 MiB  131.625 MiB           for V in Vlist:
   114  203.512 MiB    0.000 MiB               for v in V.yieldBasis(basisl, Emax):
   115                                             # Don't add twice states connected by parity inversion
   116  203.512 MiB    0.000 MiB                   if v not in vectorset and v[::-1] not in vectorset:
   117  203.461 MiB   -0.051 MiB                       vectorset.add(v)
   118                             
   119  203.512 MiB    0.051 MiB           helper = Vlist[0].helper
   120                             
   121                                     # Basis of selected states with energy <= Emax
   122  773.242 MiB  569.730 MiB           self.basisH[k] = Basis(k, (helper.torepr1(v) for v in vectorset), helper)


Filename: /Users/lorenzovitale/Phi4/phi4.py

Line #    Mem usage    Increment   Line Contents
================================================
   126  725.996 MiB    0.000 MiB       @profile
   127                                 def computeHEVs(self, k):
   128                                     """
   129                                     Compute the matrices involving the high-energy states below EL
   130                                     k: parity quantum number
   131                                     """
   132                             
   133                                     # NOTE matrix subscript notation:
   134                                     # "l": selected low-energy state with energy <= ET
   135                                     # "L": generic low-energy state with energy <= ET
   136                                     # "h": selected high-energy state with energy <= EL'
   137                                     # "H": selected high-energy states with energy <= EL
   138                             
   139                                     #################################
   140                                     # Generate the VlH matrices
   141                                     #################################
   142                             
   143  725.996 MiB    0.000 MiB           print("Computing VHl...")
   144                             
   145  725.996 MiB    0.000 MiB           basis = self.basisl[k]
   146  725.996 MiB    0.000 MiB           lookupbasis = self.basisH[k]
   147  725.996 MiB    0.000 MiB           Emax = lookupbasis.Emax
   148                             
   149 1030.137 MiB  304.141 MiB           c = MatrixConstructor(basis, lookupbasis)
   150                             
   151 1036.980 MiB    6.844 MiB           Vlist = V4OpsSelectedFull(basis, Emax)
   152 1052.270 MiB   15.289 MiB           self.VHl[k][4] = c.buildMatrix(Vlist)*self.L
   153                             
   154 1046.770 MiB   -5.500 MiB           Vlist = V2OpsSelectedFull(basis, Emax)
   155 1046.770 MiB    0.000 MiB           self.VHl[k][2] = c.buildMatrix(Vlist)*self.L
   156                             
   157  894.020 MiB -152.750 MiB           del c
   158                             
   159                                     ##############################
   160                                     # Generate the VHL matrix
   161                                     ##############################
   162                             
   163  894.020 MiB    0.000 MiB           print("Computing VHL...")
   164                             
   165  894.020 MiB    0.000 MiB           basis = self.basis[k]
   166  894.020 MiB    0.000 MiB           lookupbasis = self.basisH[k]
   167                             
   168                                     # We only need this matrix for DH2, not for DH3
   169  894.020 MiB    0.000 MiB           Emax = self.EL
   170  894.020 MiB    0.000 MiB           Erange = (0,Emax)
   171                             
   172 1060.250 MiB  166.230 MiB           c = MatrixConstructor(basis, lookupbasis, Erange=Erange)
   173                             
   174                                     # We just need the full operator
   175 1067.008 MiB    6.758 MiB           Vlist = V4OpsSelectedFull(basis, Emax)
   176 1075.887 MiB    8.879 MiB           self.VHL[k] = c.buildMatrix(Vlist, ignKeyErr=True)*self.L
   177 1075.887 MiB    0.000 MiB           self.VLH[k] = self.VHL[k].transpose()
   178                             
   179  924.637 MiB -151.250 MiB           del c
   180                             
   181  924.637 MiB    0.000 MiB           print("self.VLH[k] size", msize(self.VLH[k]))


Filename: /Users/lorenzovitale/Phi4/phi4.py

Line #    Mem usage    Increment   Line Contents
================================================
   308  805.551 MiB    0.000 MiB       @profile
   309                                 def computeDH3(self, k, ET, ELp, ELpp, eps, loc3, loc3mix, nonloc3mix):
   310                             
   311  805.551 MiB    0.000 MiB           print("Computing DH3")
   312                             
   313  805.551 MiB    0.000 MiB           sizel = self.basisl[k].size
   314  805.551 MiB    0.000 MiB           DH3ll = scipy.sparse.csc_matrix((sizel, sizel))
   315                             
   316  805.551 MiB    0.000 MiB           VHl = {}
   317  805.551 MiB    0.000 MiB           VlH = {}
   318  805.551 MiB    0.000 MiB           for n in (2,4):
   319  805.551 MiB    0.000 MiB               VHl[n] = self.VHl[k][n]
   320  805.551 MiB    0.000 MiB               VlH[n] = VHl[n].transpose()
   321                             
   322  805.551 MiB    0.000 MiB           basis = self.basisH[k]
   323                                     # List of basis elements on which we will cycle
   324  805.551 MiB    0.000 MiB           fullIdxList = basis.irange((ET,ELp))
   325  805.551 MiB    0.000 MiB           idxlen = len(fullIdxList)
   326  805.551 MiB    0.000 MiB           chunklen = min(self.chunklen, idxlen)
   327  805.551 MiB    0.000 MiB           idxLists = [fullIdxList[x:x+chunklen] for x in range(0, idxlen, chunklen)]
   328                             
   329  805.551 MiB    0.000 MiB           print("Total number of chunks: ", len(idxLists))
   330                             
   331                             #########################################################################
   332                             # Add the "symmetric" contributions to DH3 by integrating out states with
   333                             # energy ET < E < ELp
   334                             #########################################################################
   335                             
   336                             # Propagator and projector over the states between ET and ELp
   337  793.145 MiB  -12.406 MiB           propagatorh = basis.propagator(eps, ET, ELp)
   338                             
   339                                     # XXX Move this inside the cycle and restrict idxList?
   340  792.895 MiB   -0.250 MiB           Vlist = V4OpsSelectedHalf(basis, Emax=ELp, idxList=fullIdxList)
   341                             
   342  810.184 MiB   17.289 MiB           c = MatrixConstructor(basis, basis, (ET, ELp))
   343                             
   344                                     ##############################
   345                                     # Generate the Vhh matrix
   346                                     ##############################
   347  900.027 MiB   89.844 MiB           for i,idxList in enumerate(idxLists):
   348  900.027 MiB    0.000 MiB               print("Doing chunk", i, "for Vhh")
   349                             
   350  900.027 MiB    0.000 MiB               VhhHalfPart =  c.buildMatrix(Vlist, ignKeyErr=True, sumTranspose=False,
   351  904.848 MiB    4.820 MiB                       idxList=idxList)*self.L
   352                             
   353  921.930 MiB   17.082 MiB               VhhDiagPart = scipy.sparse.spdiags(VhhHalfPart.diagonal(),0,basis.size,
   354  921.930 MiB    0.000 MiB                       basis.size)
   355                             
   356 1082.520 MiB  160.590 MiB               DH3llPart = VHl[4]*propagatorh*VhhHalfPart*propagatorh*VlH[4]*self.g4**3
   357 1083.086 MiB    0.566 MiB               DH3llPart += DH3llPart.transpose()
   358  898.523 MiB -184.562 MiB               DH3llPart -= VHl[4]*propagatorh*VhhDiagPart*propagatorh*VlH[4]*self.g4**3
   359  900.340 MiB    1.816 MiB               DH3ll += DH3llPart
   360                             
   361  900.027 MiB   -0.312 MiB               del VhhHalfPart
   362                             
   363  825.949 MiB  -74.078 MiB           del c
   364                             
   365                             #########################################################################
   366                             # Add the "mixed" contributions to DH3 by integrating out states with
   367                             # energy ET < E < ELp on one side and ELp < E < EL on the other
   368                             #########################################################################
   369                             
   370  825.949 MiB    0.000 MiB           if nonloc3mix:
   371 1037.625 MiB  211.676 MiB               c = MatrixConstructor(basis, basis, (ELp, ELpp))
   372                             
   373                             # Propagator and projector over the states between ELp and ELpp
   374 1016.602 MiB  -21.023 MiB               propagatorH = basis.propagator(eps, ELp, ELpp)
   375                             
   376                                         # XXX Move this inside the cycle and restrict idxList?
   377  683.727 MiB -332.875 MiB               VHhlist = V4OpsSelectedFull(basis, ELpp, idxList=fullIdxList)
   378                             
   379  802.250 MiB  118.523 MiB               for i, idxList in enumerate(idxLists):
   380  802.312 MiB    0.062 MiB                   print("doing chunk", i, "for VhH")
   381                             
   382  802.316 MiB    0.004 MiB                   VHhPart = c.buildMatrix(VHhlist, ignKeyErr=True, sumTranspose=False,
   383  708.129 MiB  -94.188 MiB                           idxList=idxList)*self.L
   384                             
   385  850.461 MiB  142.332 MiB                   DH3llPart = VHl[4]*propagatorh*VHhPart*propagatorH*VlH[4]*self.g4**3
   386  851.582 MiB    1.121 MiB                   DH3llPart += DH3llPart.transpose()
   387  854.324 MiB    2.742 MiB                   DH3ll += DH3llPart
   388                             
   389  802.242 MiB  -52.082 MiB                   del VHhPart
   390                             
   391  512.258 MiB -289.984 MiB               del c
   392                             
   393                             
   394                             #######################################################################
   395                             # Add the "mixed" local-nonlocal contributions to DH3 where some states
   396                             # are integrated from ET to ELp while others from ELpp to Infinity
   397                             ########################################################################
   398                             
   399  512.258 MiB    0.000 MiB           if loc3mix:
   400  512.641 MiB    0.383 MiB               VV2 = renorm.renVV2(g4=self.g4, EL=ELpp, eps=eps).VV2
   401                             
   402  462.098 MiB  -50.543 MiB               DH3llPart = VHl[2]*VV2[2]*propagatorh*VlH[4]*self.g4
   403  451.840 MiB  -10.258 MiB               DH3llPart += VHl[4]*VV2[4]*propagatorh*VlH[4]*self.g4
   404  442.363 MiB   -9.477 MiB               DH3llPart += DH3llPart.transpose()
   405  442.594 MiB    0.230 MiB               DH3ll += DH3llPart
   406                             
   407                             #####################################################
   408                             # Add the "symmetric local" parts to DH3
   409                             #####################################################
   410                             
   411  442.594 MiB    0.000 MiB           if loc3:
   412                                         Vll = {}
   413                                         for n in (0,2,4,6):
   414                                             Vll[n] = self.Vll[k][n]
   415                             
   416                                         V0V4 = self.V0V4[k]
   417                                         V2V4 = self.V2V4[k]
   418                                         V4V4 = self.V4V4[k]
   419                             
   420                             
   421                                         DH3ll += V0V4*self.VV3.V0V4[ELp]*self.g4**3
   422                                         DH3ll += V2V4*self.VV3.V2V4[ELp]*self.g4**3
   423                                         DH3ll += V4V4*self.VV3.V4V4[ELp]*self.g4**3
   424                             
   425                             
   426                                         DH3ll += Vll[0]*self.VV3.VV3loc[0][ELp]*self.g4**3
   427                                         DH3ll += Vll[2]*self.VV3.VV3loc[2][ELp]*self.g4**3
   428                                         DH3ll += Vll[4]*self.VV3.VV3loc[4][ELp]*self.g4**3
   429                                         DH3ll += Vll[6]*self.VV3.VV3loc[6][ELp]*self.g4**3
   430                             
   431  442.594 MiB    0.000 MiB           return DH3ll


Filename: eigs.py

Line #    Mem usage    Increment   Line Contents
================================================
    45   61.164 MiB    0.000 MiB   @profile
    46                             def main():
    47                             
    48   61.164 MiB    0.000 MiB       if saveondb:
    49                                     db = database.Database()
    50                             
    51   61.176 MiB    0.012 MiB       a = phi4.Phi4(m, L)
    52   61.434 MiB    0.258 MiB       a.buildBasis(Emax=ET)
    53                             
    54                             
    55  353.445 MiB  292.012 MiB       for k in klist:
    56                             
    57                                     # Compute the potential matrices in the low-energy space below ET
    58   64.945 MiB -288.500 MiB           a.computePotential(k)
    59                             
    60   64.945 MiB    0.000 MiB           print("k=", k)
    61   64.945 MiB    0.000 MiB           print("Full basis size: ", a.basis[k].size)
    62                             
    63   64.945 MiB    0.000 MiB           a.setCouplings(g4=g)
    64   64.945 MiB    0.000 MiB           print("g=", g)
    65                             
    66                             
    67                             # Compute the raw eigenvalues for cutoff ET
    68   65.273 MiB    0.328 MiB           a.computeEigval(k, ET, "raw", neigs=neigs)
    69   65.297 MiB    0.023 MiB           print("Raw vacuum:", a.eigenvalues["raw"][k][0])
    70   65.297 MiB    0.000 MiB           eps = a.eigenvalues["raw"][k][0]
    71                             
    72                             
    73                             
    74                                     # Select a set of tails and construct a Basis object
    75   65.297 MiB    0.000 MiB           vectorlist = [state for i,state in sorted(enumerate(a.basis[k]), key=lambda x:
    76   65.297 MiB    0.000 MiB                   -abs(a.eigenvectors["raw"][k][0][x[0]]))]
    77   65.297 MiB    0.000 MiB           if maxntails != None:
    78                                         vectorlist = vectorlist[:maxntails]
    79   65.297 MiB    0.000 MiB           basisl = statefuncs.Basis(k, vectorlist, a.basis[k].helper)
    80   65.297 MiB    0.000 MiB           print("Total number of tails:", basisl.size)
    81                             
    82                             
    83   65.297 MiB    0.000 MiB           print("Generating high energy basis...")
    84                                     # Generate the high-energy "selected" basis by passing a set of tails
    85                                     # and a maximum cutoff EL
    86  702.242 MiB  636.945 MiB           a.genHEBasis(k, basisl, EL=EL, ELp=ELp, ELpp=ELpp)
    87  702.242 MiB    0.000 MiB           print("Size of HE basis:", a.basisH[k].size)
    88                             
    89  725.996 MiB   23.754 MiB           a.computeLEVs(k, loc3=loc3)
    90                             
    91                             
    92  725.996 MiB    0.000 MiB           print("Computing high energy matrices...")
    93                             # Compute the matrices VLH, VHL, VHH, for the highest local cutoff ELmax.
    94                             # Later we will be varying EL, therefore taking submatrices of these.
    95                             # Computing VHH is expensive
    96  918.887 MiB  192.891 MiB           a.computeHEVs(k)
    97                             
    98                             
    99  919.840 MiB    0.953 MiB           a.computeEigval(k, ET, "renloc", eps=eps, neigs=neigs)
   100  919.840 MiB    0.000 MiB           print("Local ren vacuum:", a.eigenvalues["renloc"][k][0])
   101  919.840 MiB    0.000 MiB           eps = a.eigenvalues["renloc"][k][0]
   102                             
   103  919.840 MiB    0.000 MiB           if loc3:
   104                                         a.calcVV3([ELp], eps)
   105                             
   106  919.840 MiB    0.000 MiB           a.computeEigval(k, ET, "rentails", EL=EL, ELp=ELp, ELpp=ELpp, eps=eps,
   107  353.422 MiB -566.418 MiB                   neigs=neigs, loc3=loc3,loc3mix=loc3mix, nonloc3mix=nonloc3mix)
   108  353.438 MiB    0.016 MiB           print("Non-Local ren vacuum:", a.eigenvalues["rentails"][k][0])
   109                             
   110                             
   111  353.438 MiB    0.000 MiB           print("Number of tails:", a.ntails)
   112                             
   113  353.441 MiB    0.004 MiB           if saveondb:
   114                                         datadict = dict(k=k, ET=ET, L=L, ren="raw", g=g, neigs=neigs,
   115                                                 basisSize=a.compSize)
   116                                         db.insert(datadict=datadict, spec=a.eigenvalues["raw"][k])
   117                             
   118                             
   119                                         datadict = dict(k=k, ET=ET, L=L, ren="renloc", g=g, eps=eps, neigs=neigs,
   120                                                 basisSize=a.compSize)
   121                                         db.insert(datadict=datadict, spec=a.eigenvalues["renloc"][k])
   122                             
   123                             
   124                                         datadict = dict(k=k, ET=ET, L=L, ren="rentails", g=g, EL=EL, ELp=ELp, ELpp=ELpp,
   125                                                 ntails=a.ntails, eps=eps, neigs=neigs, basisSize=a.compSize,
   126                                                 tailsComputedAtET=ET, maxntails=maxntails)
   127                                         db.insert(datadict=datadict, spec=a.eigenvalues["rentails"][k])


