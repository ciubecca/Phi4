# Contains various functions to generate matrices and bases of states which are
# used in perturbative computation, or for a future implementation of the NLO
# formalism

from statefuncs import *
from symmetry import *
from profile_support import *
import me
from me import *
from oscillators import *
from matrix import *


def genVHl(basis, subidx, basisH, L):
    """ Generate matrix elements between two different bases of states
    basis: basis of states of row indices
    subidx: subset of the indices of the row basis
    basisH: basis of states of columns indices
    L: side of torus
    """

    Vlist = V4OpsSelectedFull(basis, basisH.helper, subidx)

    return buildMatrix(basis, Vlist, idxList=subidx,
            destbasis=basisH, sumTranspose=False)*L**2


def genVhh(basisH, L):
    """ Generate matrix elements between "high energy" states. It can be
        used for old fashioned PT at 3rd order
    basisH: basis of states of row and column indices. This basis does
        not contain all the states below the cutoff
    L: side of torus
    """

    print("Computing Vhh")

    helperH = basisH.helper

    Vlist = V4OpsSelected22(basisH, helperH)
    ret = buildMatrix(basisH, Vlist, ignKeyErr=True, sumTranspose=False)*L**2
# FIXME For the 3rd order OFPT computation we only need these oscillators
    # Vlist = V4OpsSelectedHalf(basisH, helperH)
    # ret += buildMatrix(basisH, Vlist, ignKeyErr=True, sumTranspose=True)*L**2

    return ret


def genHEBases(bases, tailidx, EL, ELp, V2=True, k=None):
    """ Generate a high-energy basis from a set of tails
    basis: Basis containing the set of tail states
    tailidx: List of indices of tail states in the full basis
    EL: maximal energy of the generated basis for DH2
    ELp: maximal energy of the generated basis for DH3. Only these states
        will be stored in representation 1
    V2: include states generated by the V2 operator
    k: if set to 1 or -1, specialize to a parity sector
    """
# Usually EL > ELp
    Emax = max(EL, ELp)

    helper = Helper(L=bases[1].helper.L, Emax=Emax,
                Lambda=bases[1].helper.Lambda, m=bases[1].helper.m)

    if k!=None:
        klist = (k,)
    else:
        klist = (-1,1)

    ret = {}
    for k in klist:
        basis = bases[k]
        subidx = tailidx[k]

        # Generate all the operators between the selected states and the states
        # in the range [0, Emax]
        Vlist = V4OpsSelectedFull(basis, helper, subidx)
        if V2:
            Vlist += V2OpsSelectedFull(basis, helper, subidx)

        statePos = {}
        stateList = []
        ncomp = []

        i = 0
        for V in Vlist:
            for v in V.yieldBasis(basis, subidx, Emax):
                if bytes(tuple(v)) not in statePos:

                    va = np.array(v)
                    transStates = {bytes(tuple(m.dot(va))) for m in helper.transfMat}

                    stateList.append(bytes(tuple(v)))
                    ncomp.append(len(transStates))

                    for s in transStates:
                        statePos[s] = i
                    i += 1

# Basis of selected states with energy <= Emax. We only need to save
# states in the type 1 representation (most memory consuming) for states
# with energy <= ELp, or ET when ELp=None
        ret[k] = Basis(k, stateList, helper, statePos, ncomp, repr1=False,
                repr1Emax=max(ELp or 0, basis.Emax))

    return ret


def gendlistsfromBasis(basis, idxList, helper, nd, ntot):
    """
    Generate a set of tuples of momenta of size nd which can be annihilated
    basis: basis of states which is acted upon by the operators
    idxList: subset of indices of states to consider
    helper: Helper object
    nd: number of annihilation operators
    ntot: total number of operators in the composite operator
    """
    ret = set()
    for i in idxList:
        state = basis.stateList[i]
        ret.update(gendlists(state=state, nd=nd, ntot=ntot, helper=helper))
    return ret


def V2OpsSelectedFull(basis, helper, idxList=None, half=False):
    """ Selected set of oscillators of the full V2 operator between some selected states
    basis: basis which is acted upon
    helper: Helper object of the destination basis
    idxList: subset of indices of states which are acted upon
    half: If True, do not keep oscillators with more annihilation than creation operators
    """

    oscEnergy = helper.oscEnergy
    Emax = helper.Emax

    if idxList == None:
        idxList = range(basis.size)

    opsList = []

    if half:
        ndlist = (0,1)
    else:
        ndlist= (0,1,2)

    for nd in ndlist:
        nc = 2-nd

        dlists = gendlistsfromBasis(basis, idxList, helper, nd, 2)

        oscList = []
        for dlist in dlists:
            clists = [clist for clist in
                        createClistsV2(helper, dlist, nc) if
                        oscEnergy(clist) <= Emax+tol]
            oscList.append((dlist, clists))

        opsList.append(LocOperator(oscList,nd,nc,helper=helper))

    return opsList


def V4OpsSelectedFull(basis, helper, idxList=None):
    """ Selected set of oscillators of the full V4 operator between some selected states
    basis: basis which is acted upon
    helper: Helper object of the destination basis
    idxList: subset of indices of states which are acted upon
    """

    oscEnergy = helper.oscEnergy
    Emax = helper.Emax

    if idxList == None:
        idxList = range(basis.size)

    opsList = []
    allowedWnPairs = None

    ndlist = (0,1,2,3,4)

    for nd in ndlist:
        nc = 4-nd

        dlists = gendlistsfromBasis(basis, idxList, helper, nd, 4)

        if nd==2:
            totpairsmomenta = set((k1[0]+k2[0],k1[1]+k2[1]) for k1,k2 in dlists)
            allowedWnPairs = helper.genMomentaPairs(totpairsmomenta)

        oscList = []
        for dlist in dlists:
            clists = [clist for clist in
                        createClistsV4(helper, dlist, nc, allowedWnPairs) if
                        oscEnergy(clist) <= Emax+tol]
            oscList.append((dlist, clists))

        opsList.append(LocOperator(oscList,nd,nc,helper=helper))

    return opsList

### XXX Exclude 22 operators
def V4OpsSelectedHalf(basis, helper, idxList=None):
    """ Selected set of oscillators of part of the V4 operator between some selected states
    basis: basis which is acted upon
    helper: Helper object of the destination basis
    idxList: subset of indices of states which are acted upon
    """

    oscEnergy = helper.oscEnergy
    Emax = helper.Emax

    if idxList == None:
        idxList = range(basis.size)

    opsList = []
    allowedWnPairs = None

    ndlist = (0,1)

    for nd in ndlist:
        nc = 4-nd

        dlists = gendlistsfromBasis(basis, idxList, helper, nd, 4)

        oscList = []
        for dlist in dlists:
            clists = [clist for clist in
                        createClistsV4(helper, dlist, nc, allowedWnPairs) if
                        oscEnergy(clist) <= Emax+tol]
            oscList.append((dlist, clists))

        opsList.append(LocOperator(oscList,nd,nc,helper=helper))

    return opsList

# XXX Do not symmetrize, could be fixed
def V4OpsSelected22(basis, helper, idxList=None):
    """ Selected set of oscillators of type (a^+ a^+ a a) of the V4 operator between some selected states
    basis: basis which is acted upon
    helper: Helper object of the destination basis
    idxList: subset of indices of states which are acted upon
    """

    oscEnergy = helper.oscEnergy
    Emax = helper.Emax

    if idxList == None:
        idxList = range(basis.size)

    opsList = []
    allowedWnPairs = None

    nc = 2
    nd = 2

    dlists = gendlistsfromBasis(basis, idxList, helper, nd, 4)

    totpairsmomenta = set((k1[0]+k2[0],k1[1]+k2[1]) for k1,k2 in dlists)
    allowedWnPairs = helper.genMomentaPairs(totpairsmomenta)

    oscList = []
    for dlist in dlists:
        clists = [clist for clist in
                    createClistsV4(helper, dlist, nc, allowedWnPairs) if
                    oscEnergy(clist) <= Emax+tol]
        oscList.append((dlist, clists))

    opsList.append(LocOperator(oscList,nd,nc,helper=helper))

    return opsList



def createClistsV2(helper, dlist, nc):
    """ Returns a list of all possible tuples of momenta which can be assigned
    to creation operators in the V2 composite operator, for a given set of annihilation operators.
    helper: Helper object
    dlist: set of annihilation momenta
    nc: number of creation operators
    """
# XXX Check

    if len(dlist) != 2-nc:
        raise ValueError
    if nc==0:
        return [()]
    elif nc==1:
        return [dlist]
    elif nc==2:
        clists = []
        for wn in helper.allowedWn.keys():
            wn2 = (-wn[0], -wn[1])
            if wn >= wn2:
                clists.append((wn,wn2))
        return clists


def createClistsV4(helper, dlist, nc, allowedWnPairs=None):
    """ Returns a list of all possible tuples of momenta which can be assigned
    to creation operators in the V4 composite operator, for a given set of annihilation operators.
    helper: Helper object
    dlist: set of annihilation momenta
    nc: number of creation operators
    allowedWnPairs: precomputed data structure
    """

    if len(dlist) != 4-nc:
        raise ValueError
    clists = []

    if nc==0:
        clists.append(())

    elif nc==1:
        clists.append((sum(map(np.array, dlist)),))

    elif nc==2:
        k1,k2 = dlist
        k12 = (k1[0]+k2[0],k1[1]+k2[1])

        for k3,k4 in allowedWnPairs[k12]:
            clists.append((k3,k4))

    elif nc==3:
        (k1,) = dlist
        clists = helper.genMomenta3sets(k1)

    elif nc==4:
        clists = helper.genMomenta4sets()

    return clists
